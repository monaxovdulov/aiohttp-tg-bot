"""
offset — идентификатор первого апдейта,
который должен быть возвращён (включительно) в следующем запросе.
Это указание серверу от клиента:

  'я обработал все апдейты с update_id < offset;
   начинай отдавать с этого update_id и дальше (≥ offset)'.

Апдейт считается подтверждённым, как только getUpdates вызван с offset,
большим его update_id (то есть всё, что < offset, больше не вернётся).

Почему на пустом ответе offset НЕ двигаем:
- подтверждать нечего (ничего не получили и не обработали);
- есть риск гонки: между двумя вызовами мог появиться апдейт с id == last_seen,
 если сдвинуть offset вперёд, он будет подтверждён 'вслепую' и потеряется.

Наглядные примеры (апдейты на сервере: [78, 79, 80, 81]):

1) Старт без offset
   getUpdates() → [78, 79, 80, 81]
   next_offset = 81 + 1 = 82
   getUpdates(offset=82) → []  (пока новых нет)

2) Начать 'с середины'
   getUpdates(offset=80) → [80, 81]
   next_offset = 82
   Всё, что < 80, считается подтверждённым.

3) Отрицательный offset (взять «хвост»)
   getUpdates(offset=-2) → [80, 81]
   Всё, что раньше этих двух, забывается для нового старта.
   next_offset = 82

4) Пустой ответ
   Было last_seen = 82
   getUpdates(offset=82) → []
   offset не двигаем (ждём дальше); так исключаем потерю апдейтов из-за гонки.

5) С лимитом (для понимания 'включительно')
   getUpdates(offset=78, limit=2) → [78, 79]
   next_offset = 80
   getUpdates(offset=80, limit=2) → [80, 81]
   next_offset = 82

Правила для поллера как двигать offset

1) Пришли апдейты → посчитай next = max(update_id) + 1 → ОБРАБОТАЙ все → 
   только после успешной обработки сохрани offset = next.

2) Ответ пустой (updates == []) → offset НЕ меняй → сразу делай следующий запрос.

3) Во время обработки случилась ошибка → offset НЕ трогай. 
   Делайм следующий запрос с тем же offset.

4) Перезапуск процесса/сервиса → начинаем с последнего сохранённого offset. 
   Это 'закладка' для клиента, откуда продолжать.

5) Никогда не подтверждай  'вслепую' — не увеличивай offset, 
   если апдейт ещё не обработан.

Кратко: 'Обновляю offset ТОЛЬКО после успешной обработки непустого ответа'.
"""
from src.tg_poller.state import next_offset, Update


def test_next_offset_with_updates():
    """
    Что проверяем:
    Следующий offset должен быть равен max(update_id) + 1,
    чтобы не получать дубликаты.

    Пример:
    В очереди есть апдейты с id:
      78, 79, 80, 81
    Дано: мы делаем первый вызов без offset (или offset=None) и получаем все четыре.
    Когда: считаем следующий offset как max + 1.
    Тогда: next_offset = 81 + 1 = 82.
    """
    
    updates = [
      Update(78),
      Update(79),
      Update(80),
      Update(81)
    ]
    assert next_offset(updates=updates) == 82
    

def test_next_offset_empty_with_none_is_zero():
    """
    Что проверяем:
    При первом вызове без offset (offset=None) и пустом ответе
    следующий offset должен быть 0.
    Пример:
    В очереди нет апдейтов.
    Дано: мы делаем первый вызов без offset (или offset=None) и получаем пустой список.
    Когда: считаем следующий offset.
    Тогда: next_offset = 0.
    """
    
    updates = []
    assert next_offset(updates=updates, prev_offset=None) == 0  
    

def test_next_offset_empty_keeps_prev():
    """
    Что проверяем:
    При пустом ответе следующий offset должен остаться прежним.
    Пример:
    В очереди нет апдейтов.
    Дано: мы делаем вызов с offset=50 и получаем пустой список.
    Когда: считаем следующий offset.
    Тогда: next_offset = 50 (без изменений).
    """
    assert next_offset(updates=[], prev_offset=50) == 50
